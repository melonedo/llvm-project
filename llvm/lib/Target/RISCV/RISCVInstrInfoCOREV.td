//===-- RISCVInstrInfoCOREV.td - CORE-V instructions -------*- tablegen -*-===//
//
// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
// See https://llvm.org/LICENSE.txt for license information.
// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
//
//===----------------------------------------------------------------------===//
//
// This file describes the CORE-V instructions.
//
//===----------------------------------------------------------------------===//

include "RISCVInstrFormatsCOREV.td"

def AddrRegReg : ComplexPattern<iPTR, 2, "SelectAddrRegReg">;

def CVUImm1AsmOperand : AsmOperandClass {
  let Name = "CVUImm1";
  let RenderMethod = "addImmOperands";
  let DiagnosticType = "InvalidCVUImm1";
}

class CVUImmAsmOperand<int width> : AsmOperandClass {
  let Name = "CVUImm" # width;
  let RenderMethod = "addImmOperands";
  let DiagnosticType = !strconcat("Invalid", Name);
}

def cv_uimm1 : Operand<XLenVT>, ImmLeaf<XLenVT, [{return isUInt<1>(Imm);}]> {
  let ParserMatchClass = CVUImm1AsmOperand;
  let DecoderMethod = "decodeUImmOperand<1>";
  let MCOperandPredicate = [{
    int64_t Imm;
    if (MCOp.evaluateAsConstantImm(Imm))
      return isUInt<1>(Imm);
    return false;
  }];
  let OperandType = "OPERAND_UIMM1";
  let OperandNamespace = "RISCVOp";
}

def cv_uimm5 : Operand<XLenVT>,
               ImmLeaf<XLenVT, [{return isUInt<5>(Imm) && (Imm & 1) == 0;}]> {
  let ParserMatchClass = CVUImmAsmOperand<5>;
  let EncoderMethod = "getImmOpValue";
  let DecoderMethod = "decodeUImmOperand<5>";
  let MCOperandPredicate = [{
    int64_t Imm;
    if (MCOp.evaluateAsConstantImm(Imm))
      return isUInt<5>(Imm) && (Imm & 1) == 0;
    return MCOp.isBareSymbolRef();
  }];
  let OperandType = "OPERAND_UIMM5";
  let OperandNamespace = "RISCVOp";
}

def cv_uimm12 : Operand<XLenVT>,
                ImmLeaf<XLenVT, [{return isUInt<12>(Imm) && (Imm & 1) == 0;}]> {
  let ParserMatchClass = CVUImmAsmOperand<12>;
  let EncoderMethod = "getImmOpValue";
  let DecoderMethod = "decodeUImmOperand<12>";
  let MCOperandPredicate = [{
    int64_t Imm;
    if (MCOp.evaluateAsConstantImm(Imm))
      return isUInt<12>(Imm) && (Imm & 1) == 0;
    return MCOp.isBareSymbolRef();
  }];
  let OperandType = "OPERAND_UIMM12";
  let OperandNamespace = "RISCVOp";
}

def cv_tsimm6 : Operand<XLenVT>, TImmLeaf<XLenVT, [{return isInt<6>(Imm);}]> {
  let ParserMatchClass = SImmAsmOperand<6>;
  let EncoderMethod = "getImmOpValue";
  let DecoderMethod = "decodeSImmOperand<6>";
  let OperandType = "OPERAND_SIMM6";
  let OperandNamespace = "RISCVOp";
  let MCOperandPredicate = [{
    int64_t Imm;
    if (MCOp.evaluateAsConstantImm(Imm))
      return isInt<6>(Imm);
    return MCOp.isBareSymbolRef();
  }];
}

//===----------------------------------------------------------------------===//
// CORE-V specific instructions
//===----------------------------------------------------------------------===//

let Predicates = [HasExtXCoreVHwlp], hasSideEffects = 1, mayLoad = 0, mayStore = 0 in {
  def CV_STARTI  : RVInstHwlp_i<0b000, (ins cv_uimm1:$imm1, cv_uimm12:$imm12),
                                "cv.starti", "$imm1, $imm12">,
                   Sched<[]>;
  def CV_ENDI    : RVInstHwlp_i<0b001, (ins cv_uimm1:$imm1, cv_uimm12:$imm12),
                                "cv.endi", "$imm1, $imm12">,
                   Sched<[]>;
  def CV_COUNT   : RVInstHwlp_r<0b010, (ins cv_uimm1:$imm1, GPR:$rs1),
                                "cv.count", "$imm1, $rs1">,
                   Sched<[]>;
  def CV_COUNTI  : RVInstHwlp_i<0b011, (ins cv_uimm1:$imm1, uimm12:$imm12),
                                "cv.counti", "$imm1, $imm12">,
                   Sched<[]>;
  def CV_SETUP   : RVInstHwlp_ri<0b100, (ins cv_uimm1:$imm1, GPR:$rs1, cv_uimm12:$imm12),
                                 "cv.setup", "$imm1, $rs1, $imm12">,
                   Sched<[]>;
  def CV_SETUPI  : RVInstHwlp_ii<0b101, (ins cv_uimm1:$imm1, uimm12:$imm12, cv_uimm5:$imm5),
                              "cv.setupi", "$imm1, $imm12, $imm5">,
                Sched<[]>;
} // Predicates = [HasExtXCoreVHwlp], hasSideEffects = 1, mayLoad = 0, mayStore = 0

let Predicates = [HasExtXCoreVMac], hasSideEffects = 0, mayLoad = 0, mayStore = 0, Constraints = "$rd = $rd_wb" in {
  // 32x32 bit macs
  def CV_MAC      : RVInstMac<0b0100001, 0b000, (outs GPR:$rd_wb), (ins GPR:$rd, GPR:$rs1, GPR:$rs2),
                              "cv.mac", "$rd, $rs1, $rs2", []>,
                    Sched<[]>;
  def CV_MSU      : RVInstMac<0b0100001, 0b001, (outs GPR:$rd_wb), (ins GPR:$rd, GPR:$rs1, GPR:$rs2),
                              "cv.msu", "$rd, $rs1, $rs2", []>,
                    Sched<[]>;

  // Signed 16x16 bit macs with imm
  def CV_MACSN    : RVInstMac16I<0b10, 0b001, (outs GPR:$rd_wb), (ins GPR:$rd, GPR:$rs1, GPR:$rs2, uimm5:$imm5),
                                 "cv.macsn", "$rd, $rs1, $rs2, $imm5", []>,
                    Sched<[]>;
  def CV_MACHHSN  : RVInstMac16I<0b11, 0b001, (outs GPR:$rd_wb), (ins GPR:$rd, GPR:$rs1, GPR:$rs2, uimm5:$imm5),
                                 "cv.machhsn", "$rd, $rs1, $rs2, $imm5", []>,
                    Sched<[]>;
  def CV_MACSRN   : RVInstMac16I<0b10, 0b101, (outs GPR:$rd_wb), (ins GPR:$rd, GPR:$rs1, GPR:$rs2, uimm5:$imm5),
                                 "cv.macsrn", "$rd, $rs1, $rs2, $imm5", []>,
                    Sched<[]>;
  def CV_MACHHSRN : RVInstMac16I<0b11, 0b101, (outs GPR:$rd_wb), (ins GPR:$rd, GPR:$rs1, GPR:$rs2, uimm5:$imm5),
                                 "cv.machhsrn", "$rd, $rs1, $rs2, $imm5", []>,
                    Sched<[]>;

  // Unsigned 16x16 bit macs with imm
  def CV_MACUN    : RVInstMac16I<0b00, 0b001, (outs GPR:$rd_wb), (ins GPR:$rd, GPR:$rs1, GPR:$rs2, uimm5:$imm5),
                                 "cv.macun", "$rd, $rs1, $rs2, $imm5", []>,
                    Sched<[]>;
  def CV_MACHHUN  : RVInstMac16I<0b01, 0b001, (outs GPR:$rd_wb), (ins GPR:$rd, GPR:$rs1, GPR:$rs2, uimm5:$imm5),
                                 "cv.machhun", "$rd, $rs1, $rs2, $imm5", []>,
                    Sched<[]>;
  def CV_MACURN   : RVInstMac16I<0b00, 0b101, (outs GPR:$rd_wb), (ins GPR:$rd, GPR:$rs1, GPR:$rs2, uimm5:$imm5),
                                 "cv.macurn", "$rd, $rs1, $rs2, $imm5", []>,
                    Sched<[]>;
  def CV_MACHHURN : RVInstMac16I<0b01, 0b101, (outs GPR:$rd_wb), (ins GPR:$rd, GPR:$rs1, GPR:$rs2, uimm5:$imm5),
                                 "cv.machhurn", "$rd, $rs1, $rs2, $imm5", []>,
                    Sched<[]>;
} // Predicates = [HasExtXCoreVMac], hasSideEffects = 0, mayLoad = 0, mayStore = 0, Constraints = "$rd = $rd_wb"


let hasSideEffects = 0, mayLoad = 0, mayStore = 0 in
class CVSIMDALUrr<bits<5> funct5, bit F, bit funct1, bits<3> funct3, string opcodestr>
    : CVInstSIMDRR<funct5, F, funct1, funct3, OPC_CUSTOM3, (outs GPR:$rd),
              (ins GPR:$rs1, GPR:$rs2), opcodestr, "$rd, $rs1, $rs2"> {
}

class CVSIMDALUri<bits<5> funct5, bit F, bits<3> funct3, string opcodestr>
    : CVInstSIMDRI<funct5, F, funct3, OPC_CUSTOM3, (outs GPR:$rd),
              (ins GPR:$rs1, simm6:$imm6), opcodestr, "$rd, $rs1, $imm6"> {
}

class CVSIMDALUru<bits<5> funct5, bit F, bits<3> funct3, string opcodestr>
    : CVSIMDALUri<funct5, F, funct3, opcodestr>;

class CVSIMDALUr<bits<5> funct5, bit F, bit funct1, bits<3> funct3, string opcodestr>
    : CVInstSIMDR<funct5, F, funct1, funct3, OPC_CUSTOM3, (outs GPR:$rd),
              (ins GPR:$rs1), opcodestr, "$rd, $rs1"> {
}

multiclass CVSIMDBinarySigned<bits<5> funct5, bit F, bit funct1, string mnemonic> {
  def CV_ # NAME # _H : CVSIMDALUrr<funct5, F, funct1, 0b000, "cv." # mnemonic # ".h">;
  def CV_ # NAME # _B : CVSIMDALUrr<funct5, F, funct1, 0b001, "cv." # mnemonic # ".b">;
  def CV_ # NAME # _SC_H : CVSIMDALUrr<funct5, F, funct1, 0b100, "cv." # mnemonic # ".sc.h">;
  def CV_ # NAME # _SC_B : CVSIMDALUrr<funct5, F, funct1, 0b101, "cv." # mnemonic # ".sc.b">;
  def CV_ # NAME # _SCI_H : CVSIMDALUri<funct5, F, 0b110, "cv." # mnemonic # ".sci.h">;
  def CV_ # NAME # _SCI_B : CVSIMDALUri<funct5, F, 0b111, "cv." # mnemonic # ".sci.b">;
}

multiclass CVSIMDBinaryUnsigned<bits<5> funct5, bit F, bit funct1, string mnemonic> {
  def CV_ # NAME # _H : CVSIMDALUrr<funct5, F, funct1, 0b000, "cv." # mnemonic # ".h">;
  def CV_ # NAME # _B : CVSIMDALUrr<funct5, F, funct1, 0b001, "cv." # mnemonic # ".b">;
  def CV_ # NAME # _SC_H : CVSIMDALUrr<funct5, F, funct1, 0b100, "cv." # mnemonic # ".sc.h">;
  def CV_ # NAME # _SC_B : CVSIMDALUrr<funct5, F, funct1, 0b101, "cv." # mnemonic # ".sc.b">;
  def CV_ # NAME # _SCI_H : CVSIMDALUru<funct5, F, 0b110, "cv." # mnemonic # ".sci.h">;
  def CV_ # NAME # _SCI_B : CVSIMDALUru<funct5, F, 0b111, "cv." # mnemonic # ".sci.b">;
}


let Predicates = [HasExtXcvsimd], hasSideEffects = 0, mayLoad = 0, mayStore = 0 in {
  defm ADD :    CVSIMDBinarySigned<0b00000, 0, 0, "add">;
  defm SUB :    CVSIMDBinarySigned<0b00001, 0, 0, "sub">;
  defm AVG :    CVSIMDBinarySigned<0b00010, 0, 0, "avg">;
  defm AVGU :   CVSIMDBinarySigned<0b00011, 0, 0, "avgu">;
  defm MIN :    CVSIMDBinarySigned<0b00100, 0, 0, "min">;
  defm MINU : CVSIMDBinaryUnsigned<0b00101, 0, 0, "minu">;
  defm MAX :    CVSIMDBinarySigned<0b00110, 0, 0, "max">;
  defm MAXU : CVSIMDBinaryUnsigned<0b00111, 0, 0, "maxu">;
  defm SRL :  CVSIMDBinaryUnsigned<0b01000, 0, 0, "srl">;
  defm SRA :  CVSIMDBinaryUnsigned<0b01001, 0, 0, "sra">;
  defm SLL :  CVSIMDBinaryUnsigned<0b01010, 0, 0, "sll">;
  defm OR :     CVSIMDBinarySigned<0b01011, 0, 0, "or">;
  defm XOR :    CVSIMDBinarySigned<0b01100, 0, 0, "xor">;
  defm AND :    CVSIMDBinarySigned<0b01101, 0, 0, "and">;

  def CV_ABS_H :    CVSIMDALUr<0b01110, 0, 0, 0b000, "cv.abs.h">;
  def CV_ABS_B :    CVSIMDALUr<0b01110, 0, 0, 0b001, "cv.abs.b">;

  // 0b01111xx: UNDEF

  defm DOTUP :   CVSIMDBinarySigned<0b10000, 0, 0, "dotup">;
  defm DOTUSP :  CVSIMDBinarySigned<0b10001, 0, 0, "dotusp">;
  defm DOTSP :   CVSIMDBinarySigned<0b10010, 0, 0, "dotsp">;
  defm SDOTUP :  CVSIMDBinarySigned<0b10011, 0, 0, "sdotup">;
  defm SDOTUSP : CVSIMDBinarySigned<0b10100, 0, 0, "sdotusp">;
  defm SDOTSP :  CVSIMDBinarySigned<0b10101, 0, 0, "sdotsp">;

  // 0b10110xx: UNDEF

  def CV_EXTRACT_H :    CVSIMDALUri<0b10111, 0, 0b000, "cv.extract.h">;
  def CV_EXTRACT_B :    CVSIMDALUri<0b10111, 0, 0b001, "cv.extract.b">;
  def CV_EXTRACTU_H :   CVSIMDALUri<0b10111, 0, 0b010, "cv.extractu.h">;
  def CV_EXTRACTU_B :   CVSIMDALUri<0b10111, 0, 0b011, "cv.extractu.b">;
  let Constraints = "$rd = $rd_wb" in {
    def CV_INSERT_H : CVInstSIMDRI<0b10111, 0, 0b100, OPC_CUSTOM3, (outs GPR:$rd_wb),
      (ins GPR:$rd, GPR:$rs1, cv_tsimm6:$imm6), "cv.insert.h", "$rd, $rs1, $imm6">;
    def CV_INSERT_B : CVInstSIMDRI<0b10111, 0, 0b101, OPC_CUSTOM3, (outs GPR:$rd_wb),
      (ins GPR:$rd, GPR:$rs1, cv_tsimm6:$imm6), "cv.insert.b", "$rd, $rs1, $imm6">;
  }

  def CV_SHUFFLE_H :    CVSIMDALUrr<0b11000, 0, 0, 0b000, "cv.shuffle.h">;
  def CV_SHUFFLE_B :    CVSIMDALUrr<0b11000, 0, 0, 0b001, "cv.shuffle.b">;
  def CV_SHUFFLE_SCI_H : CVSIMDALUri<0b11000, 0, 0b110, "cv.shuffle.sci.h">;
  def CV_SHUFFLEI0_SCI_B : CVSIMDALUri<0b11000, 0, 0b111, "cv.shuffleI0.sci.b">;

  def CV_SHUFFLEI1_SCI_B : CVSIMDALUri<0b11001, 0, 0b111, "cv.shuffleI1.sci.b">;

  def CV_SHUFFLEI2_SCI_B : CVSIMDALUri<0b11010, 0, 0b111, "cv.shuffleI2.sci.b">;

  def CV_SHUFFLEI3_SCI_B : CVSIMDALUri<0b11011, 0, 0b111, "cv.shuffleI3.sci.b">;

  def CV_SHUFFLE2_H :    CVSIMDALUrr<0b11100, 0, 0, 0b000, "cv.shuffle2.h">;
  def CV_SHUFFLE2_B :    CVSIMDALUrr<0b11100, 0, 0, 0b001, "cv.shuffle2.b">;

  // 0b11101xx: UNDEF

  def CV_PACK :      CVSIMDALUrr<0b11110, 0, 0, 0b000, "cv.pack">;
  def CV_PACK_H :    CVSIMDALUrr<0b11110, 0, 1, 0b000, "cv.pack.h">;
  
  let Constraints = "$rd = $rd_wb" in {
    def CV_PACKHI_B : CVInstSIMDRR<0b11111, 0, 1, 0b001, OPC_CUSTOM3, (outs GPR:$rd_wb),
      (ins GPR:$rd, GPR:$rs1, GPR:$rs2), "cv.packhi.b", "$rd, $rs1, $rs2">;
    def CV_PACKLO_B : CVInstSIMDRR<0b11111, 0, 0, 0b001, OPC_CUSTOM3, (outs GPR:$rd_wb),
      (ins GPR:$rd, GPR:$rs1, GPR:$rs2), "cv.packlo.b", "$rd, $rs1, $rs2">;
  }
  
  defm CMPEQ : CVSIMDBinarySigned<0b00000, 1, 0, "cmpeq">;
  defm CMPNE :  CVSIMDBinarySigned<0b00001, 1, 0, "cmpne">;
  defm CMPGT :  CVSIMDBinarySigned<0b00010, 1, 0, "cmpgt">;
  defm CMPGE :  CVSIMDBinarySigned<0b00011, 1, 0, "cmpge">;
  defm CMPLT :  CVSIMDBinarySigned<0b00100, 1, 0, "cmplt">;
  defm CMPLE :  CVSIMDBinarySigned<0b00101, 1, 0, "cmple">;
  defm CMPGTU : CVSIMDBinarySigned<0b00110, 1, 0, "cmpgtu">;
  defm CMPGEU : CVSIMDBinarySigned<0b00111, 1, 0, "cmpgeu">;
  defm CMPLTU : CVSIMDBinarySigned<0b01000, 1, 0, "cmpltu">;
  defm CMPLEU : CVSIMDBinarySigned<0b01001, 1, 0, "cmpleu">;

  def CV_CPLXMUL_R :    CVSIMDALUrr<0b01010, 1, 0, 0b000, "cv.cplxmul.r">;
  def CV_CPLXMUL_I :    CVSIMDALUrr<0b01010, 1, 1, 0b000, "cv.cplxmul.i">;
  def CV_CPLXMUL_R_DIV2 :    CVSIMDALUrr<0b01010, 1, 0, 0b010, "cv.cplxmul.r.div2">;
  def CV_CPLXMUL_I_DIV2 :    CVSIMDALUrr<0b01010, 1, 1, 0b010, "cv.cplxmul.i.div2">;
  def CV_CPLXMUL_R_DIV4 :    CVSIMDALUrr<0b01010, 1, 0, 0b100, "cv.cplxmul.r.div4">;
  def CV_CPLXMUL_I_DIV4 :    CVSIMDALUrr<0b01010, 1, 1, 0b100, "cv.cplxmul.i.div4">; 
  def CV_CPLXMUL_R_DIV8 :    CVSIMDALUrr<0b01010, 1, 0, 0b110, "cv.cplxmul.r.div8">;
  def CV_CPLXMUL_I_DIV8 :    CVSIMDALUrr<0b01010, 1, 1, 0b110, "cv.cplxmul.i.div8">;

  def CV_CPLXCONJ :    CVSIMDALUr<0b01011, 1, 0, 0b000, "cv.cplxconj">;

  // 0b01011xx: UNDEF

  def CV_SUBROTMJ :    CVSIMDALUrr<0b01100, 1, 0, 0b000, "cv.subrotmj">;
  def CV_SUBROTMJ_DIV2 :    CVSIMDALUrr<0b01100, 1, 0, 0b010, "cv.subrotmj.div2">;
  def CV_SUBROTMJ_DIV4 :    CVSIMDALUrr<0b01100, 1, 0, 0b100, "cv.subrotmj.div4">; 
  def CV_SUBROTMJ_DIV8 :    CVSIMDALUrr<0b01100, 1, 0, 0b110, "cv.subrotmj.div8">;  

  def CV_ADD_DIV2 :    CVSIMDALUrr<0b01101, 1, 0, 0b010, "cv.add.div2">;
  def CV_ADD_DIV4 :    CVSIMDALUrr<0b01101, 1, 0, 0b100, "cv.add.div4">;
  def CV_ADD_DIV8 :    CVSIMDALUrr<0b01101, 1, 0, 0b110, "cv.add.div8">;

  def CV_SUB_DIV2 :    CVSIMDALUrr<0b01110, 1, 0, 0b010, "cv.sub.div2">;
  def CV_SUB_DIV4 :    CVSIMDALUrr<0b01110, 1, 0, 0b100, "cv.sub.div4">;
  def CV_SUB_DIV8 :    CVSIMDALUrr<0b01110, 1, 0, 0b110, "cv.sub.div8">; 
}

let Predicates = [HasExtXCoreVMac], hasSideEffects = 0, mayLoad = 0, mayStore = 0 in {
  // Signed 16x16 bit muls
  def CV_MULS     : RVInstMac16<0b10, 0b000, (outs GPR:$rd), (ins GPR:$rs1, GPR:$rs2),
                                "cv.muls", "$rd, $rs1, $rs2", []>,
                    Sched<[]>;
  def CV_MULHHS   : RVInstMac16<0b11, 0b000, (outs GPR:$rd), (ins GPR:$rs1, GPR:$rs2),
                                "cv.mulhhs", "$rd, $rs1, $rs2", []>,
                    Sched<[]>;

  // Signed 16x16 bit muls with imm
  def CV_MULSN    : RVInstMac16I<0b10, 0b000, (outs GPR:$rd), (ins GPR:$rs1, GPR:$rs2, uimm5:$imm5),
                                 "cv.mulsn", "$rd, $rs1, $rs2, $imm5", []>,
                    Sched<[]>;
  def CV_MULHHSN  : RVInstMac16I<0b11, 0b000, (outs GPR:$rd), (ins GPR:$rs1, GPR:$rs2, uimm5:$imm5),
                                 "cv.mulhhsn", "$rd, $rs1, $rs2, $imm5", []>,
                    Sched<[]>;
  def CV_MULSRN   : RVInstMac16I<0b10, 0b100, (outs GPR:$rd), (ins GPR:$rs1, GPR:$rs2, uimm5:$imm5),
                                 "cv.mulsrn", "$rd, $rs1, $rs2, $imm5", []>,
                    Sched<[]>;
  def CV_MULHHSRN : RVInstMac16I<0b11, 0b100, (outs GPR:$rd), (ins GPR:$rs1, GPR:$rs2, uimm5:$imm5),
                                 "cv.mulhhsrn", "$rd, $rs1, $rs2, $imm5", []>,
                    Sched<[]>;

  // Unsigned 16x16 bit muls
  def CV_MULU     : RVInstMac16<0b00, 0b000, (outs GPR:$rd), (ins GPR:$rs1, GPR:$rs2),
                                "cv.mulu", "$rd, $rs1, $rs2", []>,
                    Sched<[]>;
  def CV_MULHHU   : RVInstMac16<0b01, 0b000, (outs GPR:$rd), (ins GPR:$rs1, GPR:$rs2),
                                "cv.mulhhu", "$rd, $rs1, $rs2", []>,
                    Sched<[]>;

  // Unsigned 16x16 bit muls with imm
  def CV_MULUN    : RVInstMac16I<0b00, 0b000, (outs GPR:$rd), (ins GPR:$rs1, GPR:$rs2, uimm5:$imm5),
                                 "cv.mulun", "$rd, $rs1, $rs2, $imm5", []>,
                    Sched<[]>;
  def CV_MULHHUN  : RVInstMac16I<0b01, 0b000, (outs GPR:$rd), (ins GPR:$rs1, GPR:$rs2, uimm5:$imm5),
                                 "cv.mulhhun", "$rd, $rs1, $rs2, $imm5", []>,
                    Sched<[]>;
  def CV_MULURN   : RVInstMac16I<0b00, 0b100, (outs GPR:$rd), (ins GPR:$rs1, GPR:$rs2, uimm5:$imm5),
                                 "cv.mulurn", "$rd, $rs1, $rs2, $imm5", []>,
                    Sched<[]>;
  def CV_MULHHURN : RVInstMac16I<0b01, 0b100, (outs GPR:$rd), (ins GPR:$rs1, GPR:$rs2, uimm5:$imm5),
                                 "cv.mulhhurn", "$rd, $rs1, $rs2, $imm5", []>,
                    Sched<[]>;
} // Predicates = [HasExtXCoreVMac], hasSideEffects = 0, mayLoad = 0, mayStore = 0

let Predicates = [HasExtXCoreVAlu], hasSideEffects = 0, mayLoad = 0, mayStore = 0 in {
  // General ALU Operations
  def CV_ABS    : RVInstAlu_r<0b0000010, 0b000, (outs GPR:$rd), (ins GPR:$rs1),
                              "cv.abs", "$rd, $rs1", []>,
                  Sched<[]>;
  def CV_SLET   : RVInstAlu_rr<0b0000010, 0b010, (outs GPR:$rd), (ins GPR:$rs1, GPR:$rs2),
                               "cv.slet", "$rd, $rs1, $rs2", []>,
                  Sched<[]>;
  def CV_SLETU  : RVInstAlu_rr<0b0000010, 0b011, (outs GPR:$rd), (ins GPR:$rs1, GPR:$rs2),
                               "cv.sletu", "$rd, $rs1, $rs2", []>,
                  Sched<[]>;
  def CV_MIN    : RVInstAlu_rr<0b0000010, 0b100, (outs GPR:$rd), (ins GPR:$rs1, GPR:$rs2),
                               "cv.min", "$rd, $rs1, $rs2", []>,
                  Sched<[]>;
  def CV_MINU   : RVInstAlu_rr<0b0000010, 0b101, (outs GPR:$rd), (ins GPR:$rs1, GPR:$rs2),
                               "cv.minu", "$rd, $rs1, $rs2", []>,
                  Sched<[]>;
  def CV_MAX    : RVInstAlu_rr<0b0000010, 0b110, (outs GPR:$rd), (ins GPR:$rs1, GPR:$rs2),
                               "cv.max", "$rd, $rs1, $rs2", []>,
                  Sched<[]>;
  def CV_MAXU   : RVInstAlu_rr<0b0000010, 0b111, (outs GPR:$rd), (ins GPR:$rs1, GPR:$rs2),
                               "cv.maxu", "$rd, $rs1, $rs2", []>,
                  Sched<[]>;
  def CV_EXTHS  : RVInstAlu_r<0b0001000, 0b100, (outs GPR:$rd), (ins GPR:$rs1),
                              "cv.exths", "$rd, $rs1", []>,
                  Sched<[]>;
  def CV_EXTHZ  : RVInstAlu_r<0b0001000, 0b101, (outs GPR:$rd), (ins GPR:$rs1),
                              "cv.exthz", "$rd, $rs1", []>,
                  Sched<[]>;
  def CV_EXTBS  : RVInstAlu_r<0b0001000, 0b110, (outs GPR:$rd), (ins GPR:$rs1),
                              "cv.extbs", "$rd, $rs1", []>,
                  Sched<[]>;
  def CV_EXTBZ  : RVInstAlu_r<0b0001000, 0b111, (outs GPR:$rd), (ins GPR:$rs1),
                              "cv.extbz", "$rd, $rs1", []>,
                  Sched<[]>;

  def CV_CLIP   : RVInstAlu_ri<0b0001010, 0b001, (outs GPR:$rd), (ins GPR:$rs1, uimm5:$imm5),
                               "cv.clip", "$rd, $rs1, $imm5", []>,
                  Sched<[]>;
  def CV_CLIPU  : RVInstAlu_ri<0b0001010, 0b010, (outs GPR:$rd), (ins GPR:$rs1, uimm5:$imm5),
                               "cv.clipu", "$rd, $rs1, $imm5", []>,
                  Sched<[]>;
  def CV_CLIPR  : RVInstAlu_rr<0b0001010, 0b101, (outs GPR:$rd), (ins GPR:$rs1, GPR:$rs2),
                               "cv.clipr", "$rd, $rs1, $rs2", []>,
                  Sched<[]>;
  def CV_CLIPUR : RVInstAlu_rr<0b0001010, 0b110, (outs GPR:$rd), (ins GPR:$rs1, GPR:$rs2),
                               "cv.clipur", "$rd, $rs1, $rs2", []>,
                  Sched<[]>;

  def CV_ADDN   : RVInstAlu_rri<0b00, 0b010, (outs GPR:$rd), (ins GPR:$rs1, GPR:$rs2, uimm5:$imm5),
                                "cv.addn", "$rd, $rs1, $rs2, $imm5", []>,
                  Sched<[]>;
  def CV_ADDUN  : RVInstAlu_rri<0b10, 0b010, (outs GPR:$rd), (ins GPR:$rs1, GPR:$rs2, uimm5:$imm5),
                                "cv.addun", "$rd, $rs1, $rs2, $imm5", []>,
                  Sched<[]>;
  def CV_ADDRN  : RVInstAlu_rri<0b00, 0b110, (outs GPR:$rd), (ins GPR:$rs1, GPR:$rs2, uimm5:$imm5),
                                "cv.addrn", "$rd, $rs1, $rs2, $imm5", []>,
                  Sched<[]>;
  def CV_ADDURN : RVInstAlu_rri<0b10, 0b110, (outs GPR:$rd), (ins GPR:$rs1, GPR:$rs2, uimm5:$imm5),
                                "cv.addurn", "$rd, $rs1, $rs2, $imm5", []>,
                  Sched<[]>;
  def CV_SUBN   : RVInstAlu_rri<0b00, 0b011, (outs GPR:$rd), (ins GPR:$rs1, GPR:$rs2, uimm5:$imm5),
                                "cv.subn", "$rd, $rs1, $rs2, $imm5", []>,
                  Sched<[]>;
  def CV_SUBUN  : RVInstAlu_rri<0b10, 0b011, (outs GPR:$rd), (ins GPR:$rs1, GPR:$rs2, uimm5:$imm5),
                                "cv.subun", "$rd, $rs1, $rs2, $imm5", []>,
                  Sched<[]>;
  def CV_SUBRN  : RVInstAlu_rri<0b00, 0b111, (outs GPR:$rd), (ins GPR:$rs1, GPR:$rs2, uimm5:$imm5),
                                "cv.subrn", "$rd, $rs1, $rs2, $imm5", []>,
                  Sched<[]>;
  def CV_SUBURN : RVInstAlu_rri<0b10, 0b111, (outs GPR:$rd), (ins GPR:$rs1, GPR:$rs2, uimm5:$imm5),
                                "cv.suburn", "$rd, $rs1, $rs2, $imm5", []>,
                  Sched<[]>;
} // Predicates = [HasExtXCoreVAlu], hasSideEffects = 0, mayLoad = 0, mayStore = 0

let Predicates = [HasExtXCoreVAlu], hasSideEffects = 0, mayLoad = 0, mayStore = 0, Opcode = OPC_CUSTOM2.Value, Constraints = "$rd = $rd_wb" in {
  def CV_ADDNR   : RVInstAlu_rr<0b0100000, 0b010, (outs GPR:$rd_wb), (ins GPR:$rd, GPR:$rs1, GPR:$rs2),
                                "cv.addnr", "$rd, $rs1, $rs2", []>,
                   Sched<[]>;
  def CV_ADDUNR  : RVInstAlu_rr<0b1100000, 0b010, (outs GPR:$rd_wb), (ins GPR:$rd, GPR:$rs1, GPR:$rs2),
                                "cv.addunr", "$rd, $rs1, $rs2", []>,
                   Sched<[]>;
  def CV_ADDRNR  : RVInstAlu_rr<0b0100000, 0b110, (outs GPR:$rd_wb), (ins GPR:$rd, GPR:$rs1, GPR:$rs2),
                                "cv.addrnr", "$rd, $rs1, $rs2", []>,
                   Sched<[]>;
  def CV_ADDURNR : RVInstAlu_rr<0b1100000, 0b110, (outs GPR:$rd_wb), (ins GPR:$rd, GPR:$rs1, GPR:$rs2),
                                "cv.addurnr", "$rd, $rs1, $rs2", []>,
                   Sched<[]>;
  def CV_SUBNR   : RVInstAlu_rr<0b0100000, 0b011, (outs GPR:$rd_wb), (ins GPR:$rd, GPR:$rs1, GPR:$rs2),
                                "cv.subnr", "$rd, $rs1, $rs2", []>,
                   Sched<[]>;
  def CV_SUBUNR  : RVInstAlu_rr<0b1100000, 0b011, (outs GPR:$rd_wb), (ins GPR:$rd, GPR:$rs1, GPR:$rs2),
                                "cv.subunr", "$rd, $rs1, $rs2", []>,
                   Sched<[]>;
  def CV_SUBRNR  : RVInstAlu_rr<0b0100000, 0b111, (outs GPR:$rd_wb), (ins GPR:$rd, GPR:$rs1, GPR:$rs2),
                                "cv.subrnr", "$rd, $rs1, $rs2", []>,
                   Sched<[]>;
  def CV_SUBURNR : RVInstAlu_rr<0b1100000, 0b111, (outs GPR:$rd_wb), (ins GPR:$rd, GPR:$rs1, GPR:$rs2),
                                "cv.suburnr", "$rd, $rs1, $rs2", []>,
                   Sched<[]>;

} // Predicates = [HasExtXCoreVAlu], hasSideEffects = 0, mayLoad = 0, mayStore = 0, Opcode = OPC_CUSTOM2.Value, Constraints = "$rd = $rd_wb"

let Predicates = [HasExtXCoreVAlu], hasSideEffects = 0, mayLoad = 0, mayStore = 0, isBranch = 1, isTerminator = 1 in {
  // Immediate branching operations
  def CV_BEQIMM : RVInstImmBranch<0b010, (outs), (ins GPR:$rs1, simm5:$imm5, simm13_lsb0:$imm12),
                                  "cv.beqimm", "$rs1, $imm5, $imm12", []>,
                  Sched<[]>;
  def CV_BNEIMM : RVInstImmBranch<0b011, (outs), (ins GPR:$rs1, simm5:$imm5, simm13_lsb0:$imm12),
                                  "cv.bneimm", "$rs1, $imm5, $imm12", []>,
                  Sched<[]>;

} // Predicates = [HasExtXCoreVAlu], hasSideEffects = 0, mayLoad = 0, mayStore = 0, isBranch = 1, isTerminator = 1

let Predicates = [HasExtXCoreVMem], hasSideEffects = 0, mayLoad = 1, mayStore = 0, Constraints = "$rs1_wb = $rs1" in {
  // Register-Immediate load with post-increment
  def CV_LB_ri_inc  : RVInstLoad_ri_inc<0b000, (outs GPR:$rd, GPR:$rs1_wb), (ins GPR:$rs1, simm12:$imm12),
                                        "cv.lb", "$rd, ${imm12}(${rs1}!)", []>,
                      Sched<[]>;
  def CV_LBU_ri_inc : RVInstLoad_ri_inc<0b100, (outs GPR:$rd, GPR:$rs1_wb), (ins GPR:$rs1, simm12:$imm12),
                                        "cv.lbu", "$rd, ${imm12}(${rs1}!)", []>,
                      Sched<[]>;
  def CV_LH_ri_inc  : RVInstLoad_ri_inc<0b001, (outs GPR:$rd, GPR:$rs1_wb), (ins GPR:$rs1, simm12:$imm12),
                                        "cv.lh", "$rd, ${imm12}(${rs1}!)", []>,
                      Sched<[]>;
  def CV_LHU_ri_inc : RVInstLoad_ri_inc<0b101, (outs GPR:$rd, GPR:$rs1_wb), (ins GPR:$rs1, simm12:$imm12),
                                        "cv.lhu", "$rd, ${imm12}(${rs1}!)", []>,
                      Sched<[]>;
  def CV_LW_ri_inc  : RVInstLoad_ri_inc<0b010, (outs GPR:$rd, GPR:$rs1_wb), (ins GPR:$rs1, simm12:$imm12),
                                        "cv.lw", "$rd, ${imm12}(${rs1}!)", []>,
                      Sched<[]>;

  // Register-Register load with post-increment
  def CV_LB_rr_inc  : RVInstLoad_rr_inc<0b0000000, (outs GPR:$rd, GPR:$rs1_wb), (ins GPR:$rs1, GPR:$rs2),
                                        "cv.lb", "$rd, ${rs2}(${rs1}!)", []>,
                      Sched<[]>;
  def CV_LBU_rr_inc : RVInstLoad_rr_inc<0b0100000, (outs GPR:$rd, GPR:$rs1_wb), (ins GPR:$rs1, GPR:$rs2),
                                        "cv.lbu", "$rd, ${rs2}(${rs1}!)", []>,
                      Sched<[]>;
  def CV_LH_rr_inc  : RVInstLoad_rr_inc<0b0001000, (outs GPR:$rd, GPR:$rs1_wb), (ins GPR:$rs1, GPR:$rs2),
                                        "cv.lh", "$rd, ${rs2}(${rs1}!)", []>,
                      Sched<[]>;
  def CV_LHU_rr_inc : RVInstLoad_rr_inc<0b0101000, (outs GPR:$rd, GPR:$rs1_wb), (ins GPR:$rs1, GPR:$rs2),
                                        "cv.lhu", "$rd, ${rs2}(${rs1}!)", []>,
                      Sched<[]>;
  def CV_LW_rr_inc  : RVInstLoad_rr_inc<0b0010000, (outs GPR:$rd, GPR:$rs1_wb), (ins GPR:$rs1, GPR:$rs2),
                                        "cv.lw", "$rd, ${rs2}(${rs1}!)", []>,
                      Sched<[]>;
} // Predicates = [HasExtXCoreVMem], hasSideEffects = 0, mayLoad = 1, mayStore = 0, Constraints = "$rs1_wb = $rs1"

let Predicates = [HasExtXCoreVMem], hasSideEffects = 0, mayLoad = 1, mayStore = 0 in {
  // Register-Register load
  def CV_LB_rr  : RVInstLoad_rr<0b0000000, (outs GPR:$rd), (ins GPR:$rs1, GPR:$rs2),
                                        "cv.lb", "$rd, ${rs2}(${rs1})", []>,
                      Sched<[]>;
  def CV_LBU_rr : RVInstLoad_rr<0b0100000, (outs GPR:$rd), (ins GPR:$rs1, GPR:$rs2),
                                        "cv.lbu", "$rd, ${rs2}(${rs1})", []>,
                      Sched<[]>;
  def CV_LH_rr  : RVInstLoad_rr<0b0001000, (outs GPR:$rd), (ins GPR:$rs1, GPR:$rs2),
                                        "cv.lh", "$rd, ${rs2}(${rs1})", []>,
                      Sched<[]>;
  def CV_LHU_rr : RVInstLoad_rr<0b0101000, (outs GPR:$rd), (ins GPR:$rs1, GPR:$rs2),
                                        "cv.lhu", "$rd, ${rs2}(${rs1})", []>,
                      Sched<[]>;
  def CV_LW_rr  : RVInstLoad_rr<0b0010000, (outs GPR:$rd), (ins GPR:$rs1, GPR:$rs2),
                                        "cv.lw", "$rd, ${rs2}(${rs1})", []>,
                      Sched<[]>;

} // Predicates = [HasExtXCoreVMem], hasSideEffects = 0, mayLoad = 1, mayStore = 0

let Predicates = [HasExtXCoreVMem], hasSideEffects = 0, mayLoad = 0, mayStore = 1, Constraints = "$rs1_wb = $rs1" in {
  // Register-Immediate store with post-increment
  def CV_SB_ri_inc : RVInstStore_ri_inc<0b000, (outs GPR:$rs1_wb), (ins GPR:$rs2, GPR:$rs1, simm12:$imm12),
                                        "cv.sb", "$rs2, ${imm12}(${rs1}!)", []>,
                     Sched<[]>;
  def CV_SH_ri_inc : RVInstStore_ri_inc<0b001, (outs GPR:$rs1_wb), (ins GPR:$rs2, GPR:$rs1, simm12:$imm12),
                                        "cv.sh", "$rs2, ${imm12}(${rs1}!)", []>,
                     Sched<[]>;
  def CV_SW_ri_inc : RVInstStore_ri_inc<0b010, (outs GPR:$rs1_wb), (ins GPR:$rs2, GPR:$rs1, simm12:$imm12),
                                        "cv.sw", "$rs2, ${imm12}(${rs1}!)", []>,
                     Sched<[]>;

  // Register-Register store with post-increment
  def CV_SB_rr_inc : RVInstStore_rr_inc<0b100, (outs GPR:$rs1_wb), (ins GPR:$rs2, GPR:$rs1, GPR:$rs3),
                                        "cv.sb", "$rs2, ${rs3}(${rs1}!)", []>,
                     Sched<[]>;
  def CV_SH_rr_inc : RVInstStore_rr_inc<0b101, (outs GPR:$rs1_wb), (ins GPR:$rs2, GPR:$rs1, GPR:$rs3),
                                        "cv.sh", "$rs2, ${rs3}(${rs1}!)", []>,
                     Sched<[]>;
  def CV_SW_rr_inc : RVInstStore_rr_inc<0b110, (outs GPR:$rs1_wb), (ins GPR:$rs2, GPR:$rs1, GPR:$rs3),
                                        "cv.sw", "$rs2, ${rs3}(${rs1}!)", []>,
                     Sched<[]>;
} // Predicates = [HasExtXCoreVMem], hasSideEffects = 0, mayLoad = 0, mayStore = 1, Constraints = "$rs1_wb = $rs1"

let Predicates = [HasExtXCoreVMem], hasSideEffects = 0, mayLoad = 0, mayStore = 1 in {
  // Register-Register store
  def CV_SB_rr : RVInstStore_rr<0b100, (outs), (ins GPR:$rs2, GPR:$rs1, GPR:$rs3),
                                "cv.sb", "$rs2, ${rs3}(${rs1})", []>,
                 Sched<[]>;
  def CV_SH_rr : RVInstStore_rr<0b101, (outs), (ins GPR:$rs2, GPR:$rs1, GPR:$rs3),
                                "cv.sh", "$rs2, ${rs3}(${rs1})", []>,
                 Sched<[]>;
  def CV_SW_rr : RVInstStore_rr<0b110, (outs), (ins GPR:$rs2, GPR:$rs1, GPR:$rs3),
                                "cv.sw", "$rs2, ${rs3}(${rs1})", []>,
                 Sched<[]>;

} // Predicates = [HasExtXCoreVMem], hasSideEffects = 0, mayLoad = 0, mayStore = 1



//===----------------------------------------------------------------------===//
// CORE-V specific helper fragments
//===----------------------------------------------------------------------===//

def powerOf2 : ImmLeaf<XLenVT, [{ return isPowerOf2_32(Imm); }]>;
def powerOf2Minus1 : ImmLeaf<XLenVT, [{ return isPowerOf2_32(Imm+1); }]>;
def negativePowerOf2 : ImmLeaf<XLenVT, [{ return isPowerOf2_32(-Imm); }]>;

def shiftRound : PatFrag<(ops node:$value, node:$shiftAmount),
                         (sra (add node:$value, powerOf2), node:$shiftAmount), [{

  if (auto powerOf2 = dyn_cast<ConstantSDNode>(N->getOperand(0)->getOperand(1)))
    return (powerOf2->getZExtValue() << 1) == (1U << N->getConstantOperandVal(1));
  return false;
}]>;

def ushiftRound : PatFrag<(ops node:$value, node:$shiftAmount),
                          (srl (add node:$value, powerOf2), node:$shiftAmount), [{

  if (auto powerOf2 = dyn_cast<ConstantSDNode>(N->getOperand(0)->getOperand(1)))
    return (powerOf2->getZExtValue() << 1) == (1U << N->getConstantOperandVal(1));
  return false;
}]>;

def muls   : PatFrag<(ops node:$rs1, node:$rs2),
                     (mul (sext_inreg node:$rs1, i16), (sext_inreg node:$rs2, i16))>;
def mulhhs : PatFrag<(ops node:$rs1, node:$rs2),
                     (mul (sra node:$rs1, (i32 16)), (sra node:$rs2, (i32 16)))>;
def mulu   : PatFrag<(ops node:$rs1, node:$rs2),
                     (mul (and node:$rs1, 0xffff), (and node:$rs2, 0xffff))>;
def mulhhu : PatFrag<(ops node:$rs1, node:$rs2),
                     (mul (srl node:$rs1, (i32 16)), (srl node:$rs2, (i32 16)))>;

def macs   : PatFrag<(ops node:$rd, node:$rs1, node:$rs2),
                     (add node:$rd, (muls node:$rs1, node:$rs2))>;
def machhs : PatFrag<(ops node:$rd, node:$rs1, node:$rs2),
                     (add node:$rd, (mulhhs node:$rs1, node:$rs2))>;
def macu   : PatFrag<(ops node:$rd, node:$rs1, node:$rs2),
                     (add node:$rd, (mulu node:$rs1, node:$rs2))>;
def machhu : PatFrag<(ops node:$rd, node:$rs1, node:$rs2),
                     (add node:$rd, (mulhhu node:$rs1, node:$rs2))>;

def between : PatFrags<(ops node:$lowerBound, node:$upperBound, node:$value),
                       [(smin (smax node:$value, node:$lowerBound), node:$upperBound),
                        (smax (smin node:$value, node:$upperBound), node:$lowerBound)]>;

def betweenu : PatFrags<(ops node:$upperBound, node:$value),
                        [(umin (umax node:$value, 0), node:$upperBound),
                         (umax (umin node:$value, node:$upperBound), 0)]>;


def clip : PatFrag<(ops node:$upperBound, node:$value),
                   (between negativePowerOf2, node:$upperBound, node:$value), [{
  // Checking lower & upper bound for the clip instruction
  if (auto bound1 = dyn_cast<ConstantSDNode>(N->getOperand(0)->getOperand(1))) {
    if (auto bound2 = dyn_cast<ConstantSDNode>(N->getOperand(1))) {
      return (bound1->getSExtValue() == ~bound2->getSExtValue());
    }
  }
  return false;
}]>;

def roundBit : PatFrag<(ops node:$shiftAmount),
                       (srl (shl 1, node:$shiftAmount), (i32 1))>;

def trailing1sPlus1 : SDNodeXForm<imm, [{
  return CurDAG->getTargetConstant(
                          countTrailingOnes<uint32_t>(N->getSExtValue()) + 1,
                          SDLoc(N), N->getValueType(0));
}]>;

//===----------------------------------------------------------------------===//
// Patterns for MAC operations
//===----------------------------------------------------------------------===//


let Predicates = [HasExtXCoreVMac] in {

  def : Pat<(add GPR:$rd, (mul GPR:$rs1, GPR:$rs2)),
            (CV_MAC GPR:$rd, GPR:$rs1, GPR:$rs2)>;
  def : Pat<(sub GPR:$rd, (mul GPR:$rs1, GPR:$rs2)),
            (CV_MSU GPR:$rd, GPR:$rs1, GPR:$rs2)>;

  def : Pat<(muls GPR:$rs1, GPR:$rs2),
            (CV_MULS GPR:$rs1, GPR:$rs2)>;
  def : Pat<(mulhhs GPR:$rs1, GPR:$rs2),
            (CV_MULHHS GPR:$rs1, GPR:$rs2)>;
  def : Pat<(sra (muls GPR:$rs1, GPR:$rs2), uimm5:$imm5),
            (CV_MULSN GPR:$rs1, GPR:$rs2, uimm5:$imm5)>;
  def : Pat<(sra (mulhhs GPR:$rs1, GPR:$rs2), uimm5:$imm5),
            (CV_MULHHSN GPR:$rs1, GPR:$rs2, uimm5:$imm5)>;
  def : Pat<(shiftRound (muls GPR:$rs1, GPR:$rs2), uimm5:$imm5),
            (CV_MULSRN GPR:$rs1, GPR:$rs2, uimm5:$imm5)>;
  def : Pat<(shiftRound (mulhhs GPR:$rs1, GPR:$rs2), uimm5:$imm5),
            (CV_MULHHSRN GPR:$rs1, GPR:$rs2, uimm5:$imm5)>;

  def : Pat<(mulu GPR:$rs1, GPR:$rs2),
            (CV_MULU GPR:$rs1, GPR:$rs2)>;
  def : Pat<(mulhhu GPR:$rs1, GPR:$rs2),
            (CV_MULHHU GPR:$rs1, GPR:$rs2)>;
  def : Pat<(srl (mulu GPR:$rs1, GPR:$rs2), uimm5:$imm5),
            (CV_MULUN GPR:$rs1, GPR:$rs2, uimm5:$imm5)>;
  def : Pat<(srl (mulhhu GPR:$rs1, GPR:$rs2), uimm5:$imm5),
            (CV_MULHHUN GPR:$rs1, GPR:$rs2, uimm5:$imm5)>;
  def : Pat<(ushiftRound (mulu GPR:$rs1, GPR:$rs2), uimm5:$imm5),
            (CV_MULURN GPR:$rs1, GPR:$rs2, uimm5:$imm5)>;
  def : Pat<(ushiftRound (mulhhu GPR:$rs1, GPR:$rs2), uimm5:$imm5),
            (CV_MULHHURN GPR:$rs1, GPR:$rs2, uimm5:$imm5)>;

  def : Pat<(sra (macs GPR:$rd, GPR:$rs1, GPR:$rs2), uimm5:$imm5),
            (CV_MACSN GPR:$rd, GPR:$rs1, GPR:$rs2, uimm5:$imm5)>;
  def : Pat<(sra (machhs GPR:$rd, GPR:$rs1, GPR:$rs2), uimm5:$imm5),
            (CV_MACHHSN GPR:$rd, GPR:$rs1, GPR:$rs2, uimm5:$imm5)>;
  def : Pat<(shiftRound (macs GPR:$rd, GPR:$rs1, GPR:$rs2), uimm5:$imm5),
            (CV_MACSRN GPR:$rd, GPR:$rs1, GPR:$rs2, uimm5:$imm5)>;
  def : Pat<(shiftRound (machhs GPR:$rd, GPR:$rs1, GPR:$rs2), uimm5:$imm5),
            (CV_MACHHSRN GPR:$rd, GPR:$rs1, GPR:$rs2, uimm5:$imm5)>;

  def : Pat<(srl (macu GPR:$rd, GPR:$rs1, GPR:$rs2), uimm5:$imm5),
            (CV_MACUN GPR:$rd, GPR:$rs1, GPR:$rs2, uimm5:$imm5)>;
  def : Pat<(srl (machhu GPR:$rd, GPR:$rs1, GPR:$rs2), uimm5:$imm5),
            (CV_MACHHUN GPR:$rd, GPR:$rs1, GPR:$rs2, uimm5:$imm5)>;
  def : Pat<(ushiftRound (macu GPR:$rd, GPR:$rs1, GPR:$rs2), uimm5:$imm5),
            (CV_MACURN GPR:$rd, GPR:$rs1, GPR:$rs2, uimm5:$imm5)>;
  def : Pat<(ushiftRound (machhu GPR:$rd, GPR:$rs1, GPR:$rs2), uimm5:$imm5),
            (CV_MACHHURN GPR:$rd, GPR:$rs1, GPR:$rs2, uimm5:$imm5)>;

}

//===----------------------------------------------------------------------===//
// Patterns for general ALU operations
//===----------------------------------------------------------------------===//

let Predicates = [HasExtXCoreVAlu] in {

  def : Pat<(abs GPR:$rs1), (CV_ABS GPR:$rs1)>;
  def : PatGprGpr<setle, CV_SLET>;
  def : PatGprGpr<setule, CV_SLETU>;
  def : PatGprGpr<smin, CV_MIN>;
  def : PatGprGpr<umin, CV_MINU>;
  def : PatGprGpr<smax, CV_MAX>;
  def : PatGprGpr<umax, CV_MAXU>;

  def : Pat<(sext_inreg GPR:$rs1, i16), (CV_EXTHS GPR:$rs1)>;
  def : Pat<(sext_inreg GPR:$rs1, i8), (CV_EXTBS GPR:$rs1)>;
  def : Pat<(and GPR:$rs1, 0xffff), (CV_EXTHZ GPR:$rs1)>;
  def : Pat<(and GPR:$rs1, 0xff), (CV_EXTBZ GPR:$rs1)>;

  def : Pat<(clip powerOf2Minus1:$upperBound, GPR:$rs1),
            (CV_CLIP GPR:$rs1, (trailing1sPlus1 imm:$upperBound))>;
  def : Pat<(between (not GPR:$rs2), GPR:$rs2, GPR:$rs1),
            (CV_CLIPR GPR:$rs1, GPR:$rs2)>;
  def : Pat<(betweenu powerOf2Minus1:$upperBound, GPR:$rs1),
            (CV_CLIPU GPR:$rs1, (trailing1sPlus1 imm:$upperBound))>;
  def : Pat<(betweenu GPR:$rs2, GPR:$rs1),
            (CV_CLIPUR GPR:$rs1, GPR:$rs2)>;

  def : Pat<(sra (add GPR:$rs1, GPR:$rs2), uimm5:$imm5),
            (CV_ADDN GPR:$rs1, GPR:$rs2, uimm5:$imm5)>;
  def : Pat<(srl (add GPR:$rs1, GPR:$rs2), uimm5:$imm5),
            (CV_ADDUN GPR:$rs1, GPR:$rs2, uimm5:$imm5)>;
  def : Pat<(shiftRound (add GPR:$rs1, GPR:$rs2), uimm5:$imm5),
            (CV_ADDRN GPR:$rs1, GPR:$rs2, uimm5:$imm5)>;
  def : Pat<(ushiftRound (add GPR:$rs1, GPR:$rs2), uimm5:$imm5),
            (CV_ADDURN GPR:$rs1, GPR:$rs2, uimm5:$imm5)>;

  def : Pat<(sra (sub GPR:$rs1, GPR:$rs2), uimm5:$imm5),
            (CV_SUBN GPR:$rs1, GPR:$rs2, uimm5:$imm5)>;
  def : Pat<(srl (sub GPR:$rs1, GPR:$rs2), uimm5:$imm5),
            (CV_SUBUN GPR:$rs1, GPR:$rs2, uimm5:$imm5)>;
  def : Pat<(shiftRound (sub GPR:$rs1, GPR:$rs2), uimm5:$imm5),
            (CV_SUBRN GPR:$rs1, GPR:$rs2, uimm5:$imm5)>;
  def : Pat<(ushiftRound (sub GPR:$rs1, GPR:$rs2), uimm5:$imm5),
            (CV_SUBURN GPR:$rs1, GPR:$rs2, uimm5:$imm5)>;

  def : Pat<(sra (add GPR:$rd, GPR:$rs1), GPR:$rs2),
            (CV_ADDNR GPR:$rd, GPR:$rs1, GPR:$rs2)>;
  def : Pat<(srl (add GPR:$rd, GPR:$rs1), GPR:$rs2),
            (CV_ADDUNR GPR:$rd, GPR:$rs1, GPR:$rs2)>;
  def : Pat<(sra (add (add GPR:$rd, GPR:$rs1), (roundBit GPR:$rs2)), GPR:$rs2),
            (CV_ADDRNR  GPR:$rd, GPR:$rs1, GPR:$rs2)>;
  def : Pat<(srl (add (add GPR:$rd, GPR:$rs1), (roundBit GPR:$rs2)), GPR:$rs2),
            (CV_ADDURNR GPR:$rd, GPR:$rs1, GPR:$rs2)>;

  def : Pat<(sra (sub GPR:$rd, GPR:$rs1), GPR:$rs2),
            (CV_SUBNR GPR:$rd, GPR:$rs1, GPR:$rs2)>;
  def : Pat<(srl (sub GPR:$rd, GPR:$rs1), GPR:$rs2),
            (CV_SUBUNR GPR:$rd, GPR:$rs1, GPR:$rs2)>;
  def : Pat<(sra (add (sub GPR:$rd, GPR:$rs1), (roundBit GPR:$rs2)), GPR:$rs2),
            (CV_SUBRNR  GPR:$rd, GPR:$rs1, GPR:$rs2)>;
  def : Pat<(srl (add (sub GPR:$rd, GPR:$rs1), (roundBit GPR:$rs2)), GPR:$rs2),
            (CV_SUBURNR GPR:$rd, GPR:$rs1, GPR:$rs2)>;


//===----------------------------------------------------------------------===//
// Patterns for immediate branching operations
//===----------------------------------------------------------------------===//

  def : Pat<(riscv_brcc GPR:$rs1, simm5:$imm5, SETEQ, bb:$imm12),
            (CV_BEQIMM GPR:$rs1, simm5:$imm5, simm13_lsb0:$imm12)>;
  def : Pat<(riscv_brcc GPR:$rs1, simm5:$imm5, SETNE, bb:$imm12),
            (CV_BNEIMM GPR:$rs1, simm5:$imm5, simm13_lsb0:$imm12)>;

}

//===----------------------------------------------------------------------===//
// Patterns for load & store operations
//===----------------------------------------------------------------------===//

let Predicates = [HasExtXCoreVMem] in {

  def : Pat<(sextloadi8 (AddrRegReg GPR:$base, GPR:$offset)),
            (CV_LB_rr GPR:$base, GPR:$offset)>;
  def : Pat<(zextloadi8 (AddrRegReg GPR:$base, GPR:$offset)),
            (CV_LBU_rr GPR:$base, GPR:$offset)>;
  def : Pat<(extloadi8 (AddrRegReg GPR:$base, GPR:$offset)),
            (CV_LBU_rr GPR:$base, GPR:$offset)>;
  def : Pat<(sextloadi16 (AddrRegReg GPR:$base, GPR:$offset)),
            (CV_LH_rr GPR:$base, GPR:$offset)>;
  def : Pat<(zextloadi16 (AddrRegReg GPR:$base, GPR:$offset)),
            (CV_LHU_rr GPR:$base, GPR:$offset)>;
  def : Pat<(extloadi16 (AddrRegReg GPR:$base, GPR:$offset)),
            (CV_LHU_rr GPR:$base, GPR:$offset)>;
  def : Pat<(load (AddrRegReg GPR:$base, GPR:$offset)),
            (CV_LW_rr GPR:$base, GPR:$offset)>;

  def : Pat<(post_truncsti8 GPR:$val, GPR:$base, simm12:$offset),
            (CV_SB_ri_inc GPR:$val, GPR:$base, simm12:$offset)>;
  def : Pat<(post_truncsti16 GPR:$val, GPR:$base, simm12:$offset),
            (CV_SH_ri_inc GPR:$val, GPR:$base, simm12:$offset)>;
  def : Pat<(post_store GPR:$val, GPR:$base, simm12:$offset),
            (CV_SW_ri_inc GPR:$val, GPR:$base, simm12:$offset)>;

  def : Pat<(post_truncsti8 GPR:$val, GPR:$base, GPR:$offset),
            (CV_SB_rr_inc GPR:$val, GPR:$base, GPR:$offset)>;
  def : Pat<(post_truncsti16 GPR:$val, GPR:$base, GPR:$offset),
            (CV_SH_rr_inc GPR:$val, GPR:$base, GPR:$offset)>;
  def : Pat<(post_store GPR:$val, GPR:$base, GPR:$offset),
            (CV_SW_rr_inc GPR:$val, GPR:$base, GPR:$offset)>;

  def : Pat<(truncstorei8 GPR:$val, (AddrRegReg GPR:$base, GPR:$offset)),
            (CV_SB_rr GPR:$val, GPR:$base, GPR:$offset)>;
  def : Pat<(truncstorei16 GPR:$val, (AddrRegReg GPR:$base, GPR:$offset)),
            (CV_SH_rr GPR:$val, GPR:$base, GPR:$offset)>;
  def : Pat<(store GPR:$val, (AddrRegReg GPR:$base, GPR:$offset)),
            (CV_SW_rr GPR:$val, GPR:$base, GPR:$offset)>;

}

//===----------------------------------------------------------------------===//
// Patterns for SIMD operations
//===----------------------------------------------------------------------===//

class PatCorevGprGpr <string intr, string asm> :
  PatGprGpr<!cast<Intrinsic>("int_riscv_cv_simd_" # intr), 
            !cast<RVInst>("CV_" # asm)>;

class PatCorevGprTImm <string intr, string asm> :
  PatGprImm<!cast<Intrinsic>("int_riscv_cv_simd_" # intr), 
            !cast<RVInst>("CV_" # asm), cv_tsimm6>;

class PatCorevGprImm <string intr, string asm> :
  PatGprImm<!cast<Intrinsic>("int_riscv_cv_simd_" # intr), 
            !cast<RVInst>("CV_" # asm), simm6>;

// TODO: define uimm6
class PatCorevGprUImm <string intr, string asm> :
  PatGprImm<!cast<Intrinsic>("int_riscv_cv_simd_" # intr), 
            !cast<RVInst>("CV_" # asm), simm6>;

multiclass PatCorevGprGprHB <string intr> {
  def : PatCorevGprGpr<intr # "_h", NAME # "_H">;
  def : PatCorevGprGpr<intr # "_b", NAME # "_B">;
}

multiclass PatCorevGprTImmHB <string intr> {
  def : PatCorevGprTImm<intr # "_h", NAME # "_H">;
  def : PatCorevGprTImm<intr # "_b", NAME # "_B">;
}

multiclass PatCorevGprImmHB <string intr> {
  def : PatCorevGprImm<intr # "_h", NAME # "_H">;
  def : PatCorevGprImm<intr # "_b", NAME # "_B">;
}

multiclass PatCorevGprUImmHB <string intr> {
  def : PatCorevGprUImm<intr # "_h", NAME # "_H">;
  def : PatCorevGprUImm<intr # "_b", NAME # "_B">;
}

class PatCorevGprGprDiv <Intrinsic intr, string asm, int div> : 
  Pat<(intr GPR:$rd, GPR:$rs1, (i32 div)),
      (!cast<RVInst>("CV_" # asm) GPR:$rd, GPR:$rs1)>;

multiclass PatCorevGprGprDivAll <string intr> {
  def : PatCorevGprGpr<intr # "_div2", NAME # "_DIV2">;
  def : PatCorevGprGpr<intr # "_div4", NAME # "_DIV4">;
  def : PatCorevGprGpr<intr # "_div8", NAME # "_DIV8">;
}

multiclass PatCorevGprGprDivAll2 <Intrinsic intr> {
  def : PatCorevGprGprDiv<intr, NAME # "_DIV2", 2>;
  def : PatCorevGprGprDiv<intr, NAME # "_DIV4", 4>;
  def : PatCorevGprGprDiv<intr, NAME # "_DIV8", 8>;
}

class PatCorevGpr <string intr, string asm> :
  PatGpr<!cast<Intrinsic>("int_riscv_cv_simd_" # intr), 
            !cast<RVInst>("CV_" # asm)>;

multiclass PatCorevGprHB <string intr> {
  def : PatCorevGpr<intr # "_h", NAME # "_H">;
  def : PatCorevGpr<intr # "_b", NAME # "_B">;
}

multiclass PatCorevBinary <string intr, bit exclude_h = false> {
  if exclude_h then {
    def : PatCorevGprGpr<intr # "_b", NAME # "_B">;
  } else {
    defm NAME : PatCorevGprGprHB<intr>;
  }
  defm NAME # "_SC" : PatCorevGprGprHB<intr # "_sc">;
  defm NAME # "_SCI" : PatCorevGprImmHB<intr # "_sc">;
}

multiclass PatCorevBinaryUnsigned <string intr> {
  defm NAME : PatCorevGprGprHB<intr>;
  defm NAME # "_SC" : PatCorevGprGprHB<intr # "_sc">;
  defm NAME # "_SCI" : PatCorevGprUImmHB<intr # "_sc">;
}


let Predicates = [HasExtXcvsimd, IsRV32] in {
  defm ADD :  PatCorevBinary<"add", true>;
  def : PatCorevGprGprDiv<int_riscv_cv_simd_add_h, "ADD_H", 1>;
  defm SUB :  PatCorevBinary<"sub", true>;
  def : PatCorevGprGprDiv<int_riscv_cv_simd_sub_h, "SUB_H", 1>;
  defm AVG :  PatCorevBinary<"avg">;
  defm AVGU : PatCorevBinary<"avgu">;
  defm MIN :  PatCorevBinary<"min">;
  defm MINU : PatCorevBinaryUnsigned<"minu">;
  defm MAX :  PatCorevBinary<"max">;
  defm MAXU : PatCorevBinaryUnsigned<"maxu">;
  defm SRL :  PatCorevBinaryUnsigned<"srl">;
  defm SRA :  PatCorevBinaryUnsigned<"sra">;
  defm SLL :  PatCorevBinaryUnsigned<"sll">;
  defm OR :   PatCorevBinary<"or">;
  defm XOR :  PatCorevBinary<"xor">;
  defm AND :  PatCorevBinary<"and">;

  defm ABS : PatCorevGprHB<"abs">;

  defm DOTUP :   PatCorevBinary<"dotup">;
  defm DOTUSP :  PatCorevBinary<"dotusp">;
  defm DOTSP :   PatCorevBinary<"dotsp">;
  defm SDOTUP :  PatCorevBinary<"sdotup">;
  defm SDOTUSP : PatCorevBinary<"sdotusp">;
  defm SDOTSP :  PatCorevBinary<"sdotsp">;

  defm EXTRACT :  PatCorevGprTImmHB<"extract">;
  defm EXTRACTU : PatCorevGprTImmHB<"extractu">;
  def : Pat<(int_riscv_cv_simd_insert_b GPR:$rd, GPR:$rs1, cv_tsimm6:$imm), 
            (CV_INSERT_B GPR:$rd, GPR:$rs1, cv_tsimm6:$imm)>;
  def : Pat<(int_riscv_cv_simd_insert_h GPR:$rd, GPR:$rs1, cv_tsimm6:$imm), 
            (CV_INSERT_H GPR:$rd, GPR:$rs1, cv_tsimm6:$imm)>;

  defm SHUFFLE : PatCorevGprGprHB<"shuffle">;
  def : PatCorevGprTImm<"shuffle_sci_h", "SHUFFLE_SCI_H">;
  def : PatCorevGprTImm<"shuffleI0_sci_b", "SHUFFLEI0_SCI_B">;
  def : PatCorevGprTImm<"shuffleI1_sci_b", "SHUFFLEI1_SCI_B">;
  def : PatCorevGprTImm<"shuffleI2_sci_b", "SHUFFLEI2_SCI_B">;
  def : PatCorevGprTImm<"shuffleI3_sci_b", "SHUFFLEI3_SCI_B">;
  defm SHUFFLE2 : PatCorevGprGprHB<"shuffle2">;

  def : PatCorevGprGpr<"pack", "PACK">;
  def : PatCorevGprGpr<"pack_h", "PACK_H">;
  def : Pat<(int_riscv_cv_simd_packhi_b GPR:$rd, GPR:$rs1, GPR:$rs2), 
            (CV_PACKHI_B GPR:$rd, GPR:$rs1, GPR:$rs2)>;
  def : Pat<(int_riscv_cv_simd_packlo_b GPR:$rd, GPR:$rs1, GPR:$rs2), 
            (CV_PACKLO_B GPR:$rd, GPR:$rs1, GPR:$rs2)>;

  defm CMPEQ :  PatCorevBinary<"cmpeq">;
  defm CMPNE :  PatCorevBinary<"cmpne">;
  defm CMPGT :  PatCorevBinary<"cmpgt">;
  defm CMPGE :  PatCorevBinary<"cmpge">;
  defm CMPLT :  PatCorevBinary<"cmplt">;
  defm CMPLE :  PatCorevBinary<"cmple">;
  defm CMPGTU : PatCorevBinary<"cmpgtu">;
  defm CMPGEU : PatCorevBinary<"cmpgeu">;
  defm CMPLTU : PatCorevBinary<"cmpltu">;
  defm CMPLEU : PatCorevBinary<"cmpleu">;
  
  def : PatCorevGprGprDiv<int_riscv_cv_simd_cplxmul_r, "CPLXMUL_R", 1>;
  defm CPLXMUL_R : PatCorevGprGprDivAll2<int_riscv_cv_simd_cplxmul_r>;
  def : PatCorevGprGprDiv<int_riscv_cv_simd_cplxmul_i, "CPLXMUL_I", 1>;
  defm CPLXMUL_I : PatCorevGprGprDivAll2<int_riscv_cv_simd_cplxmul_i>;

  def : PatCorevGpr<"cplxconj", "CPLXCONJ">;

  def : PatCorevGprGprDiv<int_riscv_cv_simd_subrotmj, "SUBROTMJ", 1>;
  defm SUBROTMJ : PatCorevGprGprDivAll2<int_riscv_cv_simd_subrotmj>;

  defm ADD : PatCorevGprGprDivAll2<int_riscv_cv_simd_add_h>;
  defm SUB : PatCorevGprGprDivAll2<int_riscv_cv_simd_sub_h>;
}

//===----------------------------------------------------------------------===//
// Pseudo instructions and patterns for hardware loop generation
//===----------------------------------------------------------------------===//

let Predicates = [HasExtXCoreVHwlp], isNotDuplicable = 1,
    hasSideEffects = 1, mayLoad = 1, mayStore = 1 in {

  // RISCVInstrInfo assumes 3 operands for conditional branch instructions,
  // so we add 2 immediates and ignore them.
  let isBranch = 1, isTerminator = 1, Size = 0, mayStore = 0 in
  def HwlpBranch : Pseudo<(outs),
                          (ins uimm5:$op1, uimm5:$op2, simm13_lsb0:$rs1), []>;

  let Size = 12 in {
    def HwlpSetup : Pseudo<(outs), (ins GPR:$rs1), []>;
    def HwlpSetupImm : Pseudo<(outs), (ins uimm12:$rs1), []>;
  }
}

// We need to custom select the loop decrement intrinsic, because tablegen
// doesn't know that we promoted it to i32
def loop_decrement_32
  : ComplexPattern<i32, 0, "SelectLoopDecrement", [intrinsic_w_chain],
                   [SDNPSideEffect, SDNPMayLoad, SDNPMayStore]>;

def : Pat<(riscv_brcc (i32 (and (loop_decrement_32), 1)), 0, SETNE, bb:$branchDest),
          (HwlpBranch 0, 0, bb:$branchDest)>;

def : Pat<(int_set_loop_iterations GPR:$rs1),
          (HwlpSetup GPR:$rs1)>;

def : Pat<(int_set_loop_iterations uimm12:$rs1),
          (HwlpSetupImm uimm12:$rs1)>;
